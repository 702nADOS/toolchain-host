{
    "docs": [
        {
            "location": "/", 
            "text": "taskgen\n\n\ntaskgen\n is a taskset generation framework for the\n\ngenode-Taskloader\n\ncomponent. \n\n\nGoals\n\n\n\n\n\n\nEasy extensibility\n New modules like are simple to add as new classes. The\n  primary classes \nTaskSet\n and \nTask\n are represented as dictionaries, which\n  allows a direct mapping from \nTask\n attributes to the final xml\n  representation.\n\n\n\n\n\n\nWork with Python\n No separate models configuration files in a declarative\n  format. Models are described in Python code, which is compact, easier to\n  debug, and allows for ease of extensibility\n\n\n\n\n\n\nLarge-Scale\n TaskSet variants up to 1 billion or even infinite taskset\n  generators are no problems. Lazy evaluation only generate as much tasksets as\n  needed at runtime.\n\n\n\n\n\n\nUser friendly\n Threading keeps waiting time low and work like ping,\n  connect, processing tasksets is done in background. A fast-responsive\n  framework is the result.\n\n\n\n\n\n\nGetting started\n\n\nThe core of taskgen are the the \ntask-sets\n. This directory\ncontains abstract task-set generators and predefined out-of-the-box runnable\ntask-sets like \nTODO\n. For more complex task-set generation, you should us the\n\ntaskgen functional API\n. Another helpful tool is the command\nline application:\n\n\nusage: __main__.py run [-h] [-v] [--log-file FILE] -p PORT -t CLASS [-l CLASS]\n                       [-o CLASS] [--pretend]\n                       IP [IP ...]\n\n\n\n\nBeside a port and one or multiple IP, IP-ranges, a taskset is neccesary for\nprocessing. A taskset can have variants, which is means, that some attributes\nmay have multiple values. Every variant is executed as single taskset at one\ndestination genode instance.\nNow lets do same dry exercise and execute a taskset with its variants at\nthree destination instances. There is no need for real genode instances, the\n\n--pretend\n flag replaces the actual connection by a stub.\n\n\n./taskgen run --pretend -p 1234 -t TODO 172.25.0.1 172.25.0.2 172.25.0.3\n\n\n\n\nProject layout\n\n\nmkdocs.yml                    # documentation configuration file\ndocs/                         # documentation in markdown\nsite/                         # built html documentation\ntaskset.py                    # TaskSet base class implementation\ntasks.py                      # Periodic-, Sporadic-, AperiodicTask implementation\nlive.py                       # live request handler implementations\ndistributors/\n    simple_distributor.py     # genode distributor implementation\n    multi_distributor.py      # advanced, asyncron, multi connection distributor\nmixins/                       # direcotry for mixins (task configurations)\n    gen_load_finite.py        # binary configuration file\n    ...\ntasksets/                     # directory for taskset classes\n    ...\nlives/\n    sqlite.py                 # live request handler with sqlite support\n    ...", 
            "title": "Home"
        }, 
        {
            "location": "/#taskgen", 
            "text": "taskgen  is a taskset generation framework for the genode-Taskloader \ncomponent.", 
            "title": "taskgen"
        }, 
        {
            "location": "/#goals", 
            "text": "Easy extensibility  New modules like are simple to add as new classes. The\n  primary classes  TaskSet  and  Task  are represented as dictionaries, which\n  allows a direct mapping from  Task  attributes to the final xml\n  representation.    Work with Python  No separate models configuration files in a declarative\n  format. Models are described in Python code, which is compact, easier to\n  debug, and allows for ease of extensibility    Large-Scale  TaskSet variants up to 1 billion or even infinite taskset\n  generators are no problems. Lazy evaluation only generate as much tasksets as\n  needed at runtime.    User friendly  Threading keeps waiting time low and work like ping,\n  connect, processing tasksets is done in background. A fast-responsive\n  framework is the result.", 
            "title": "Goals"
        }, 
        {
            "location": "/#getting-started", 
            "text": "The core of taskgen are the the  task-sets . This directory\ncontains abstract task-set generators and predefined out-of-the-box runnable\ntask-sets like  TODO . For more complex task-set generation, you should us the taskgen functional API . Another helpful tool is the command\nline application:  usage: __main__.py run [-h] [-v] [--log-file FILE] -p PORT -t CLASS [-l CLASS]\n                       [-o CLASS] [--pretend]\n                       IP [IP ...]  Beside a port and one or multiple IP, IP-ranges, a taskset is neccesary for\nprocessing. A taskset can have variants, which is means, that some attributes\nmay have multiple values. Every variant is executed as single taskset at one\ndestination genode instance.\nNow lets do same dry exercise and execute a taskset with its variants at\nthree destination instances. There is no need for real genode instances, the --pretend  flag replaces the actual connection by a stub.  ./taskgen run --pretend -p 1234 -t TODO 172.25.0.1 172.25.0.2 172.25.0.3", 
            "title": "Getting started"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml                    # documentation configuration file\ndocs/                         # documentation in markdown\nsite/                         # built html documentation\ntaskset.py                    # TaskSet base class implementation\ntasks.py                      # Periodic-, Sporadic-, AperiodicTask implementation\nlive.py                       # live request handler implementations\ndistributors/\n    simple_distributor.py     # genode distributor implementation\n    multi_distributor.py      # advanced, asyncron, multi connection distributor\nmixins/                       # direcotry for mixins (task configurations)\n    gen_load_finite.py        # binary configuration file\n    ...\ntasksets/                     # directory for taskset classes\n    ...\nlives/\n    sqlite.py                 # live request handler with sqlite support\n    ...", 
            "title": "Project layout"
        }, 
        {
            "location": "/commandline/", 
            "text": "taskgen\n is the command line tool for distributing and running task-sets at\nmultiple destination instances.\n\n\nShow help information\n\n\n./taskgen --help\n./taskgen run --help\n./taskgen list --help\n\n\n\n\nConnect to a range of IP addresses\n\n\nIP ranges are defined as\n\nCIDR\n\nformat. Before a connection is established, all host are pinged.\n\n\n./taskgen run -t example.ExampleTaskSet -p 1234 172.25.0.0/24\n\n\n\n\nConnect to multiple IP addresses or IP ranges\n\n\n./taskgen run -t example.ExampleTaskSet -p 1234 172.25.0.0/24 172.26.0.0/24\n\n\n\n\nWrite log to file\n\n\n./taskgen run --log-file log.txt -t example.ExampleTaskSet -p 1234 172.25.0.1\n\n\n\n\nIncrease verbosity\n\n\n./taskgen run -vvv -t example.ExampleTaskSet -p 1234 172.25.0.1\n\n\n\n\nPretend the connection\n\n\nWhen the \n--pretend\n option is used, no real connection is established and the\nSimpleDistributor is replaced with the LogDistributor. The actual sent xml files\nare printed to stdout.\n\n\n./taskgen run --pretend -t example.ExampleTaskSet -p 1234 172.25.0.1\n\n\n\n\nChoose a Live Request Handler\n\n\n./taskgen run -l sqlite.SQLiteLiveHandler -p 1234 172.25.0.1\n\n\n\n\nChoose an optimization\n\n\n./taskgen run -o fairness.Fairness -p 1234 172.25.0.1\n\n\n\n\nList all available task-sets\n\n\n./taskgen list -t\n\n\n\n\nList all available optimizations\n\n\n./taskgen list -o\n\n\n\n\nList all available live request handlers\n\n\n./taskgen list -l", 
            "title": "Command Line Tool"
        }, 
        {
            "location": "/commandline/#show-help-information", 
            "text": "./taskgen --help\n./taskgen run --help\n./taskgen list --help", 
            "title": "Show help information"
        }, 
        {
            "location": "/commandline/#connect-to-a-range-of-ip-addresses", 
            "text": "IP ranges are defined as CIDR \nformat. Before a connection is established, all host are pinged.  ./taskgen run -t example.ExampleTaskSet -p 1234 172.25.0.0/24", 
            "title": "Connect to a range of IP addresses"
        }, 
        {
            "location": "/commandline/#connect-to-multiple-ip-addresses-or-ip-ranges", 
            "text": "./taskgen run -t example.ExampleTaskSet -p 1234 172.25.0.0/24 172.26.0.0/24", 
            "title": "Connect to multiple IP addresses or IP ranges"
        }, 
        {
            "location": "/commandline/#write-log-to-file", 
            "text": "./taskgen run --log-file log.txt -t example.ExampleTaskSet -p 1234 172.25.0.1", 
            "title": "Write log to file"
        }, 
        {
            "location": "/commandline/#increase-verbosity", 
            "text": "./taskgen run -vvv -t example.ExampleTaskSet -p 1234 172.25.0.1", 
            "title": "Increase verbosity"
        }, 
        {
            "location": "/commandline/#pretend-the-connection", 
            "text": "When the  --pretend  option is used, no real connection is established and the\nSimpleDistributor is replaced with the LogDistributor. The actual sent xml files\nare printed to stdout.  ./taskgen run --pretend -t example.ExampleTaskSet -p 1234 172.25.0.1", 
            "title": "Pretend the connection"
        }, 
        {
            "location": "/commandline/#choose-a-live-request-handler", 
            "text": "./taskgen run -l sqlite.SQLiteLiveHandler -p 1234 172.25.0.1", 
            "title": "Choose a Live Request Handler"
        }, 
        {
            "location": "/commandline/#choose-an-optimization", 
            "text": "./taskgen run -o fairness.Fairness -p 1234 172.25.0.1", 
            "title": "Choose an optimization"
        }, 
        {
            "location": "/commandline/#list-all-available-task-sets", 
            "text": "./taskgen list -t", 
            "title": "List all available task-sets"
        }, 
        {
            "location": "/commandline/#list-all-available-optimizations", 
            "text": "./taskgen list -o", 
            "title": "List all available optimizations"
        }, 
        {
            "location": "/commandline/#list-all-available-live-request-handlers", 
            "text": "./taskgen list -l", 
            "title": "List all available live request handlers"
        }, 
        {
            "location": "/api/", 
            "text": "Beside the \ntaskgen\n command line tool, you have the possibility to use the\nframework and its classes inside REPL or any other project.\n\n\nLogDistributor\n\n\nThe \nLogDistributor\n is a stub implementation for the low level communication\nwith a genode instance. Combined with the \nMultiDistributor\n, it helps you\ndebugging. Instead of sending all task-sets, the xml representation is printed\nto stdout.\n\n\nSimpleDistributor\n\n\nThe \nSimpleDistributor\n represents the most simple implementation of a\ndistributor. It connects to one genode instance and processes one taskset. It is\nable to start, stop, close and send live requests. Please do not use this\ndistributor directly, it only abstracts the low level communication for the more\nadvanced \nMultiDistributor\n.\n\n\nMultiDistributor\n\n\nThe \nMultiDistributor\n is the default distributor for communication with\nmultiple genode instances. \n\n\nTODO\n\n\nPredefined TaskSet\n\n\nTask-Sets are all located inside the \ntasksets\n directory. Each\nTask-Set is represented as subclass of \nTaskSet\n. Task-Sets can be runnable\nout-of-the-box if there are no constructor parameters. For example, the\n\ntasksets.example.ExampleTaskSet\n implementation does not need further parameters.\n\n\nfrom taskgen.tasksets.example import ExampleTaskSet\nfrom taskgen.distributors.multi_distributor import MultiDistributor\n\nts = ExampleTaskSet()\n\nmd = MultiDistributor(\n172.25.0.1\n, 1234)\nmd.start(ts)\n\n\n\n\nCustom TaskSet\n\n\nThe Usage of task-sets is not limited to predefined implementations. It is\npossible to build your custom task-set by using the base \ntaskset.TaskSet\n class\nand append your \nTask\n classes. The \ntasksets.example.ExampleTask\n is reused for\nthis example.\n\n\nfrom taskgen.tasksets.example import ExampleTask\nfrom taskgen.taskset import TaskSet\n\nts_1 = TaskSet()\n\n# add one ExampleTask object\nts_1.append( ExampleTask())\n# add another ExampleTask object\nts_1.append( ExampleTask())\n\n\n\n\nYou can concatenate tasksets:\n\n\nts_2 = TaskSet()\nts_2.append( ExampleTask())\n\nts_all = ts_1 + ts_2\n\n\n\n\nKeep in mind, that the \nTaskSet\n does not behave like a list or dictionary. Only\nthe append and concatenation-operator are supported. This has some performance\nreasons. Read the pydocs for further function definitions.\n\n\nTaskSet Variants\n\n\nTasks can store multiple values for one attribute. These leads to multiple\nvariants of Tasks and finally multiple variants of a TaskSet. There is no way to\ndetermine the actual number of variants, only if it has variants\n\nTaskSet.has_variants()\n. It also can have infinite variants, which will keep\nthe distributor running.\n\n\nCustom Task (with Mixins)\n\n\nIf you need a specific task, you do not need to redefine all behaviors. Specific\nbehaviors, like a high priority, are summarized in building blocks, called\nmixins. They are located in the \nmixins\n directory.  Furthmore there are three\ntypes of base classes: \ntask.PeriodicTask\n, \ntask.SporadicTask\n and\n\ntask.AperiodicTask\n, which serve as starting point for your customization.\n\n\nfrom taskgen.mixins.priority import HighPriority\nfrom taskgen.mixins.gen_load_finite import GenLoadFinite\nfrom taskgen.task import PeriodicTask\n\nclass MyTask(HighPriority, GenLoadFinite, PeriodicTask):\n    pass\n\n\n\n\nNow, this task can be appended in our custom task-set.\n\n\nts_4 = TaskSet()\nts_4.append( MyTask())\n\n\n\n\nKeep in mind, that the base class is always listed at the rightmost class.\n\n\nCustom Task\n\n\nMixins are not the only way, how tasks can be created. The three task classes\n\nPeriodicTask\n, \nSporadicTask\n and \nAperiodicTask\n are subtypes of the abstract\n\nTask\n class. The \nTask\n class inherits from the Python \ndict\n class. It means,\nthat all attributes of the tasks are accessed and altered with dictionary\nmethods.\n\n\nfrom taskgen.task import PeriodicTask\n\nt = PeriodicTask()\nt['priority'] = 128\nt['id'] = \nhello_world\n\n...\n\n\n\n\nEvery attribute in the Task can be a single value or of type \nIterable\n. It is\npossible to define ranges \nrange(0,10)\n, lists \n[0,1,2,3]\n or custom\n\ngenerators\n. Multiple options for a\nvalue results in multiple variants of a task and finally multiple variants of a\ntaskset. If you want to analyse, how a scheduler reacts to different values of\none or more tasks, this is your way to go.\n\n\nfrom taskgen.task import PeriodicTask\n\nt = PeriodicTask()\nt['priority'] = range(1, 128) # generates 128 variants of the task\n\nassert t.has_variants() True\n\n\n\n\nWhen it comes to the transmission of a task-set to a genode instance, a \nTask\n\nis translated to a xml representation. All dictionary attributes, even nested\ndictionaries, are directly mapped to a xml element.\n\n\nOptimization\n\n\nWhen a task-set processing starts, you are able to handle over an optimization\ngoal. These optimization goals are represented with subclasses of the\n\nOptimiziation\n class, which are located in the \noptimizations\n directory. \n\n\nfrom taskgen.optimization.fairness import Fairness\nfrom taskgen.tasksets.example import ExampleTaskSet\nfrom taskgen.distributors.multi_distributor import MultiDistributor\n\nts = ExampleTaskSet()\nmd = MultiDistributor(\n172.25.0.1\n, 1234)\n\n# optimize fairness \nopt = Fairness()\nmd.start(ts, opt)\n\n\n\n\nLive Request Handlers\n\n\nAll data from a genode instance are pulled with \nlive\n requests. The result of a\n\nlive\n request is represented with the \nLiveResult\n class. Live Request Handlers\nhandle \nLiveResult\ns and for example stores them to sqlite databases. Live\nHandlers are implemented in the \nlives\n directory.\n\n\nfrom taskgen.lives.sqlite import SQLiteLiveHandler\nfrom taskgen.tasksets.example import ExampleTaskSet\nfrom taskgen.distributors.multi_distributor import MultiDistributor\n\nmd = MultiDistributor(\n172.25.0.1\n, 1234)\n\n# save all live requests to a sqlite db.\nmd.live_handler = SQLiteLiveHandler(\n./live.db\n)\n\nts = ExampleTaskSet()\nmd.start(ts, opt)", 
            "title": "API"
        }, 
        {
            "location": "/api/#logdistributor", 
            "text": "The  LogDistributor  is a stub implementation for the low level communication\nwith a genode instance. Combined with the  MultiDistributor , it helps you\ndebugging. Instead of sending all task-sets, the xml representation is printed\nto stdout.", 
            "title": "LogDistributor"
        }, 
        {
            "location": "/api/#simpledistributor", 
            "text": "The  SimpleDistributor  represents the most simple implementation of a\ndistributor. It connects to one genode instance and processes one taskset. It is\nable to start, stop, close and send live requests. Please do not use this\ndistributor directly, it only abstracts the low level communication for the more\nadvanced  MultiDistributor .", 
            "title": "SimpleDistributor"
        }, 
        {
            "location": "/api/#multidistributor", 
            "text": "The  MultiDistributor  is the default distributor for communication with\nmultiple genode instances.   TODO", 
            "title": "MultiDistributor"
        }, 
        {
            "location": "/api/#predefined-taskset", 
            "text": "Task-Sets are all located inside the  tasksets  directory. Each\nTask-Set is represented as subclass of  TaskSet . Task-Sets can be runnable\nout-of-the-box if there are no constructor parameters. For example, the tasksets.example.ExampleTaskSet  implementation does not need further parameters.  from taskgen.tasksets.example import ExampleTaskSet\nfrom taskgen.distributors.multi_distributor import MultiDistributor\n\nts = ExampleTaskSet()\n\nmd = MultiDistributor( 172.25.0.1 , 1234)\nmd.start(ts)", 
            "title": "Predefined TaskSet"
        }, 
        {
            "location": "/api/#custom-taskset", 
            "text": "The Usage of task-sets is not limited to predefined implementations. It is\npossible to build your custom task-set by using the base  taskset.TaskSet  class\nand append your  Task  classes. The  tasksets.example.ExampleTask  is reused for\nthis example.  from taskgen.tasksets.example import ExampleTask\nfrom taskgen.taskset import TaskSet\n\nts_1 = TaskSet()\n\n# add one ExampleTask object\nts_1.append( ExampleTask())\n# add another ExampleTask object\nts_1.append( ExampleTask())  You can concatenate tasksets:  ts_2 = TaskSet()\nts_2.append( ExampleTask())\n\nts_all = ts_1 + ts_2  Keep in mind, that the  TaskSet  does not behave like a list or dictionary. Only\nthe append and concatenation-operator are supported. This has some performance\nreasons. Read the pydocs for further function definitions.", 
            "title": "Custom TaskSet"
        }, 
        {
            "location": "/api/#taskset-variants", 
            "text": "Tasks can store multiple values for one attribute. These leads to multiple\nvariants of Tasks and finally multiple variants of a TaskSet. There is no way to\ndetermine the actual number of variants, only if it has variants TaskSet.has_variants() . It also can have infinite variants, which will keep\nthe distributor running.", 
            "title": "TaskSet Variants"
        }, 
        {
            "location": "/api/#custom-task-with-mixins", 
            "text": "If you need a specific task, you do not need to redefine all behaviors. Specific\nbehaviors, like a high priority, are summarized in building blocks, called\nmixins. They are located in the  mixins  directory.  Furthmore there are three\ntypes of base classes:  task.PeriodicTask ,  task.SporadicTask  and task.AperiodicTask , which serve as starting point for your customization.  from taskgen.mixins.priority import HighPriority\nfrom taskgen.mixins.gen_load_finite import GenLoadFinite\nfrom taskgen.task import PeriodicTask\n\nclass MyTask(HighPriority, GenLoadFinite, PeriodicTask):\n    pass  Now, this task can be appended in our custom task-set.  ts_4 = TaskSet()\nts_4.append( MyTask())  Keep in mind, that the base class is always listed at the rightmost class.", 
            "title": "Custom Task (with Mixins)"
        }, 
        {
            "location": "/api/#custom-task", 
            "text": "Mixins are not the only way, how tasks can be created. The three task classes PeriodicTask ,  SporadicTask  and  AperiodicTask  are subtypes of the abstract Task  class. The  Task  class inherits from the Python  dict  class. It means,\nthat all attributes of the tasks are accessed and altered with dictionary\nmethods.  from taskgen.task import PeriodicTask\n\nt = PeriodicTask()\nt['priority'] = 128\nt['id'] =  hello_world \n...  Every attribute in the Task can be a single value or of type  Iterable . It is\npossible to define ranges  range(0,10) , lists  [0,1,2,3]  or custom generators . Multiple options for a\nvalue results in multiple variants of a task and finally multiple variants of a\ntaskset. If you want to analyse, how a scheduler reacts to different values of\none or more tasks, this is your way to go.  from taskgen.task import PeriodicTask\n\nt = PeriodicTask()\nt['priority'] = range(1, 128) # generates 128 variants of the task\n\nassert t.has_variants() True  When it comes to the transmission of a task-set to a genode instance, a  Task \nis translated to a xml representation. All dictionary attributes, even nested\ndictionaries, are directly mapped to a xml element.", 
            "title": "Custom Task"
        }, 
        {
            "location": "/api/#optimization", 
            "text": "When a task-set processing starts, you are able to handle over an optimization\ngoal. These optimization goals are represented with subclasses of the Optimiziation  class, which are located in the  optimizations  directory.   from taskgen.optimization.fairness import Fairness\nfrom taskgen.tasksets.example import ExampleTaskSet\nfrom taskgen.distributors.multi_distributor import MultiDistributor\n\nts = ExampleTaskSet()\nmd = MultiDistributor( 172.25.0.1 , 1234)\n\n# optimize fairness \nopt = Fairness()\nmd.start(ts, opt)", 
            "title": "Optimization"
        }, 
        {
            "location": "/api/#live-request-handlers", 
            "text": "All data from a genode instance are pulled with  live  requests. The result of a live  request is represented with the  LiveResult  class. Live Request Handlers\nhandle  LiveResult s and for example stores them to sqlite databases. Live\nHandlers are implemented in the  lives  directory.  from taskgen.lives.sqlite import SQLiteLiveHandler\nfrom taskgen.tasksets.example import ExampleTaskSet\nfrom taskgen.distributors.multi_distributor import MultiDistributor\n\nmd = MultiDistributor( 172.25.0.1 , 1234)\n\n# save all live requests to a sqlite db.\nmd.live_handler = SQLiteLiveHandler( ./live.db )\n\nts = ExampleTaskSet()\nmd.start(ts, opt)", 
            "title": "Live Request Handlers"
        }, 
        {
            "location": "/mixins/", 
            "text": "TODO", 
            "title": "Add Mixins"
        }, 
        {
            "location": "/tasks/", 
            "text": "Xml mapping\n\n\nWhen it comes to the transmission of a task-set to a genode instance, a \nTask\n\nis translated to a xml representation. All dictionary attributes, even nested\ndictionaries, are directly mapped to a xml element. Adding and altering\nattributes can be done by using the \ndict\n methods of the \nTask\n object or\nimplementing a \nMixin\n. The actual conversation is done by the\n\nxmltodict\n library.\n\n\nVariants\n\n\nEvery attribute in the Task can be a single value or of type \nIterable\n. It is\npossible to define ranges (\nrang(0,10)\n), lists (\n[0,1,2,3]\n) or custom\n\ngenerators\n. Multiple options for a\nvalue results in multiple variants of a task and finally in various tasksets.\nEach variant of taskset is finally processed by one genode instance.", 
            "title": "Add Tasks"
        }, 
        {
            "location": "/tasks/#xml-mapping", 
            "text": "When it comes to the transmission of a task-set to a genode instance, a  Task \nis translated to a xml representation. All dictionary attributes, even nested\ndictionaries, are directly mapped to a xml element. Adding and altering\nattributes can be done by using the  dict  methods of the  Task  object or\nimplementing a  Mixin . The actual conversation is done by the xmltodict  library.", 
            "title": "Xml mapping"
        }, 
        {
            "location": "/tasks/#variants", 
            "text": "Every attribute in the Task can be a single value or of type  Iterable . It is\npossible to define ranges ( rang(0,10) ), lists ( [0,1,2,3] ) or custom generators . Multiple options for a\nvalue results in multiple variants of a task and finally in various tasksets.\nEach variant of taskset is finally processed by one genode instance.", 
            "title": "Variants"
        }, 
        {
            "location": "/tasksets/", 
            "text": "", 
            "title": "Add Tasksets"
        }, 
        {
            "location": "/live/", 
            "text": "", 
            "title": "Add Live Handler"
        }, 
        {
            "location": "/distributor/", 
            "text": "", 
            "title": "Add Distributor"
        }, 
        {
            "location": "/ml/", 
            "text": "", 
            "title": "Machine Learning"
        }
    ]
}